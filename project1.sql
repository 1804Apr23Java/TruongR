CREATE TABLE BEAR2 (
	BEAR_ID INTEGER PRIMARY KEY,
	BEAR_NAME VARCHAR2(100),
	BEAR_BIRTHDATE DATE,
	BEAR_WEIGHT NUMBER(5,2) DEFAULT 200.00,
	BEAR_TYPE_ID INTEGER NOT NULL,
	CAVE_ID INTEGER
);
/
CREATE TABLE BEAR2_TYPE (
    BEAR_TYPE_ID INTEGER PRIMARY KEY,
    BEAR_TYPE_NAME VARCHAR2(100)
);
/
CREATE TABLE CAVE2 (
    CAVE_ID INTEGER PRIMARY KEY,
    CAVE_NAME VARCHAR2(100),
    MAX_BEARS INTEGER DEFAULT 4
);
/
CREATE TABLE BEEHIVE2 (
    BEEHIVE_ID INTEGER PRIMARY KEY,
    BEEHIVE_WEIGHT NUMBER(5, 2) DEFAULT 75.00
);
/
CREATE TABLE BEAR2_BEEHIVE2 (
    BEAR_ID INTEGER,
    BEEHIVE_ID INTEGER,
    PRIMARY KEY (BEAR_ID, BEEHIVE_ID)
);
/

--FOREIGN KEY CONSTRAINTS
ALTER TABLE BEAR2
ADD CONSTRAINT FK_BEAR2_BEAR2_TYPE 
FOREIGN KEY (BEAR_TYPE_ID) REFERENCES BEAR2_TYPE(BEAR_TYPE_ID);
/
ALTER TABLE BEAR2
ADD CONSTRAINT FK_BEAR2_CAVE
FOREIGN KEY (CAVE_ID) REFERENCES CAVE2(CAVE_ID);
/
ALTER TABLE BEAR2_BEEHIVE2
ADD CONSTRAINT FK_BEAR2_BEAR2_BEEHIVE2
FOREIGN KEY (BEAR_ID) REFERENCES BEAR2(BEAR_ID);
/
ALTER TABLE BEAR2_BEEHIVE2
ADD CONSTRAINT FK_BEEHIVE2_BEAR2_BEEHIVE2
FOREIGN KEY (BEEHIVE_ID) REFERENCES BEEHIVE2(BEEHIVE_ID);
/

--ADD SOME DATA
INSERT INTO BEAR2_TYPE(BEAR_TYPE_ID,BEAR_TYPE_NAME) VALUES (1,'Grizzly');
INSERT INTO BEAR2_TYPE(BEAR_TYPE_ID,BEAR_TYPE_NAME) VALUES (2,'Polar');

INSERT ALL
INTO CAVE2 VALUES (1,'AWESOMECAVE1', 9) 
INTO CAVE2(CAVE_ID, CAVE_NAME) VALUES (2,'AWESOMECAVE2')
SELECT * FROM DUAL;




INSERT ALL
INTO BEAR2(BEAR_ID, BEAR_NAME, BEAR_BIRTHDATE, BEAR_TYPE_ID, CAVE_ID)
VALUES (3, 'Ferdinand', TO_DATE('1987-08-18 00:00:00', 'yyyy-mm-dd hh24:mi:ss'), 1, 2)
INTO BEAR2(BEAR_ID, BEAR_NAME, BEAR_BIRTHDATE, BEAR_TYPE_ID, CAVE_ID)
VALUES (8, 'Ernest', TO_DATE('1989-08-18 00:00:00', 'yyyy-mm-dd hh24:mi:ss'), 1, 1)
INTO BEAR2
VALUES (9, 'Elon', TO_DATE('1999-02-18 00:00:00', 'yyyy-mm-dd hh24:mi:ss'), 400.00, 2, 1)
INTO BEAR2
VALUES (10, 'Jeff', TO_DATE('1597-02-18 00:00:00', 'yyyy-mm-dd hh24:mi:ss'), 450.00, 2, 1)
SELECT * FROM DUAL;

INSERT ALL
INTO BEEHIVE2
VALUES (1, 100)
INTO BEEHIVE2
VALUES (2, 950)
INTO BEEHIVE2
VALUES (3, 125)
INTO BEEHIVE2
VALUES (4, 2)
SELECT * FROM DUAL;

INSERT ALL
INTO BEAR2_BEEHIVE2
VALUES (8, 1)
INTO BEAR2_BEEHIVE2
VALUES (8, 2)
INTO BEAR2_BEEHIVE2
VALUES (9, 4)
INTO BEAR2_BEEHIVE2
VALUES (3, 3)
INTO BEAR2_BEEHIVE2
VALUES (3, 2)
INTO BEAR2_BEEHIVE2
VALUES (3, 4)
INTO BEAR2_BEEHIVE2
VALUES (10, 1)
SELECT * FROM DUAL;

--ALTER TABLE

ALTER TABLE BEAR2_TYPE 
ADD SURVIVAL_PROCEDURE VARCHAR2(200);

--ADD SOME NEW VALUES FOR ALTERED COLUMN

UPDATE BEAR2_TYPE
SET SURVIVAL_PROCEDURE = 'play dead' WHERE BEAR_TYPE_ID = 1;


UPDATE BEAR2_TYPE
SET SURVIVAL_PROCEDURE = 'run downhill, then play dead' WHERE BEAR_TYPE_ID = 1;

UPDATE BEAR2_TYPE
SET SURVIVAL_PROCEDURE = 'lol none'
WHERE BEAR_TYPE_ID = 2;

---

INSERT INTO BEAR2
VALUES(92, 'Stacy', TO_DATE('1999-02-18 00:00:00', 'yyyy-mm-dd hh24:mi:ss'), 300.00, 1, null)

SELECT *--BEAR2.BEAR_ID, BEAR2.BEAR_NAME, CAVE2.CAVE_ID, CAVE2.CAVE_NAME 
FROM BEAR2 B
FULL OUTER JOIN CAVE2 ON B.CAVE_ID = CAVE2.CAVE_ID;

--CREATE SEQUENCES and TRIGGERS TO PROVIDE PRIMARY KEY VALUES

CREATE SEQUENCE SQ_BEAR2_PK
START WITH 93
INCREMENT BY 1;
/

CREATE SEQUENCE SQ_CAVE2_PK
START WITH 3
INCREMENT BY 1;
/


CREATE SEQUENCE SQ_BEAR2_TYPE_PK
START WITH 3
INCREMENT BY 1;
/

CREATE SEQUENCE SQ_BEEHIVE2_PK
START WITH 5
INCREMENT BY 1;
/

CREATE OR REPLACE TRIGGER TR_INSERT_BEAR2
BEFORE INSERT ON BEAR2
FOR EACH ROW
BEGIN
    SELECT SQ_BEAR2_PK.NEXTVAL INTO :NEW.BEAR_ID FROM DUAL;    
END;
/

CREATE OR REPLACE TRIGGER TR_INSERT_BEEHIVE2
BEFORE INSERT ON BEEHIVE2
FOR EACH ROW
BEGIN
    SELECT SQ_BEEHIVE2_PK.NEXTVAL INTO :NEW.BEEHIVE_ID FROM DUAL;    
END;
/

CREATE OR REPLACE TRIGGER TR_INSERT_BEAR2_TYPE
BEFORE INSERT ON BEAR2_TYPE
FOR EACH ROW
BEGIN
    SELECT SQ_BEAR2_TYPE_PK.NEXTVAL INTO :NEW.BEAR_TYPE_ID FROM DUAL;    
END;
/

CREATE OR REPLACE TRIGGER TR_INSERT_CAVE2
BEFORE INSERT ON CAVE2
FOR EACH ROW
BEGIN
    SELECT SQ_CAVE2_PK.NEXTVAL INTO :NEW.CAVE_ID FROM DUAL;    
END;
/

--USE TRIGGERS TO GENERATE PRIMARY KEYS...
INSERT INTO BEAR2(BEAR_NAME, BEAR_BIRTHDATE, BEAR_WEIGHT, BEAR_TYPE_ID, CAVE_ID)
VALUES('Stacy2', TO_DATE('1999-02-18 00:00:00', 'yyyy-mm-dd hh24:mi:ss'), 300.00, 1, null)

--
ALTER TABLE BEAR2 ADD CONSTRAINT CK_BEAR_WEIGHT_POSITIVE
CHECK (BEAR_WEIGHT > 0);

ALTER TABLE BEEHIVE2 ADD CONSTRAINT CK_BEEHIVE_WEIGHT_POSITIVE
CHECK (BEEHIVE_WEIGHT > 0);

ALTER TABLE BEAR2 ADD CONSTRAINT UQ_BEAR_NAME
UNIQUE (BEAR_NAME);

--
--HOW MANY BEARS PER CAVE? NOTE: THIS USES A SYSTEM-DEFINED AGGREGATE FUNCTION COUNT.
--UNDERSTAND THE DIFFERENCE BETWEEN SCALAR AND AGGREGATE FUNCTIONS
CREATE VIEW VW_BEARS2_PER_CAVE2 (CAVE,NUMBEAR)
AS
SELECT CAVE2.CAVE_NAME, COUNT(BEAR2.BEAR_ID) 
FROM BEAR2, CAVE2
WHERE BEAR2.CAVE_ID = CAVE2.CAVE_ID 
GROUP BY CAVE_NAME;

SELECT * FROM VW_BEARS2_PER_CAVE2;

--FUNCTIONS

--SOME JAVA-LIKE FUNCTIONALITY
CREATE OR REPLACE FUNCTION FIND_MAX_NUMBER (X IN NUMBER, Y IN NUMBER)
RETURN NUMBER
IS
Z NUMBER;
BEGIN
    IF X > Y THEN
    Z := X; --PL/SQL ASSIGNMENT OPERATOR
    ELSE
    Z := Y;
    END IF;
    RETURN Z;
END;


DECLARE
FIRST_NUM NUMBER;
SECOND_NUM NUMBER;
MAX_NUM NUMBER;
BEGIN
    FIRST_NUM := 22;
    SECOND_NUM := 42;
    MAX_NUM := FIND_MAX_NUMBER(FIRST_NUM, SECOND_NUM);
    DBMS_OUTPUT.PUT_LINE('MAX: ' ||MAX_NUM);
END;

--STORED PROCEDURES

--SP WITH A CURSOR AND LOOPING, SYS_REFCURSOR DOES NOT NEED TO BE INITIALIZED

CREATE OR REPLACE PROCEDURE GET_ALL_BEARS( s OUT SYS_REFCURSOR)
IS
BEGIN
OPEN S FOR SELECT BEAR_ID, BEAR_NAME FROM BEAR2;
END;

DECLARE
S SYS_REFCURSOR;
SOME_ID BEAR2.BEAR_ID%TYPE; --SET SOME_ID AS WHATEVER DATATYPE BEAR_ID IS
SOME_NAME BEAR2.BEAR_NAME%TYPE;
BEGIN
    GET_ALL_BEARS(S);
    LOOP
        FETCH S INTO SOME_ID, SOME_NAME;
        EXIT WHEN S%NOTFOUND; -- BREAK LOOP WHEN NO MORE ROWS AVAILABLE
        DBMS_OUTPUT.PUT_LINE(SOME_ID||' IS CURRENT ID, '||SOME_NAME||' IS CURRENT NAME');
    END LOOP;
    CLOSE S;
END;


--need to fix, dont run this
CREATE OR REPLACE PROCEDURE FEED_BEAR(BEAR_ID IN NUMBER, BEEHIVE_ID IN NUMBER, AMOUNT IN NUMBER)
IS
BH_WEIGHT NUMBER;
BR_WEIGHT NUMBER;
BEGIN
    IF EXISTS (SELECT * FROM BEAR2_BEEHIVE2 WHERE BEAR_ID = BEAR2_BEEHIVE2.BEAR_ID) THEN
        ROLLBACK;
    ELSE IF (MAX(SELECT BEEHIVE_WEIGHT FROM BEEHIVE2 WHERE BEEHIVE2.BEEHIVE_ID = BEEHIVE_ID) < AMOUNT) THEN
        ROLLBACK;
    ELSE
        BR_WEIGHT := MAX(SELECT BEAR_WEIGHT FROM BEAR2 WHERE BEAR2.BEAR_ID = BEAR_ID) + AMOUNT;
        BH_WEIGHT := MAX(SELECT BEEHIVE_WEIGHT FROM BEEHIVE2 WHERE BEEHIVE2.BEEHIVE_ID = BEEHIVE_ID) - AMOUNT;
        UPDATE BEEHIVE2 SET BEEHIVE_WEIGHT = BH_WEIGHT;
        UPDATE BEAR2 SET BEAR_WEIGHT = BR_WEIGHT;
    END IF;
END;

